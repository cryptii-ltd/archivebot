import crypto from 'crypto'

/**
 * Derives a cryptographic key from the combination of user ID and server ID using PBKDF2.
 * The key is derived asynchronously to avoid blocking the event loop.
 *
 * @param {string} userId - The unique ID of the user.
 * @param {string} serverId - The unique ID of the server.
 * @returns {Promise<Buffer>} - A promise that resolves to a 128-bit derived key as a Buffer.
 */
export async function deriveKeyAsync(userId: string, serverId: string): Promise<Buffer> {
    // Create a deterministic salt by hashing the userId and serverId
    const salt = crypto.createHash('sha256').update(userId + serverId).digest()

    // Use PBKDF2 to derive a key from the userId, serverId, and the deterministic salt
    return new Promise((resolve, reject) => {
        crypto.pbkdf2(`${userId}${serverId}`, salt, 100000, 16, 'sha256', (err, derivedKey) => { // Output 128-bit (16 bytes) key
            if (err) reject(err)
            else resolve(derivedKey)
        })
    })
}

/**
 * Encrypts a plaintext message using AES-128-GCM.
 * The encryption key is derived from the user ID and server ID.
 *
 * @param {string} plaintext - The message to be encrypted.
 * @param {string} userId - The unique ID of the user.
 * @param {string} serverId - The unique ID of the server.
 * @returns {Promise<{ encryptedData: string; iv: Buffer; tag: Buffer }>} - A promise that resolves to an object containing the encrypted data, the initialization vector, and the authentication tag.
 */
export async function encryptMessageAsync(plaintext: string, userId: string, serverId: string): Promise<{ encryptedData: string; iv: Buffer; tag: Buffer }> {
    // Derive the encryption key asynchronously
    const key = await deriveKeyAsync(userId, serverId)

    // Generate a random IV (Initialization Vector) for AES-GCM
    const iv = crypto.randomBytes(12);  // 96-bit nonce for GCM

    // Create the AES-128-GCM cipher
    const cipher = crypto.createCipheriv('aes-128-gcm', key, iv)

    // Encrypt the plaintext
    let encrypted = cipher.update(plaintext, 'utf8', 'hex')
    encrypted += cipher.final('hex')

    // Retrieve the authentication tag generated by AES-GCM
    const tag = cipher.getAuthTag()

    return {
        encryptedData: encrypted,
        iv: iv,
        tag: tag
    }
}

/**
 * Decrypts an encrypted message using AES-128-GCM.
 * The decryption key is derived from the user ID and server ID.
 *
 * @param {string} encryptedData - The encrypted message in hexadecimal format.
 * @param {Buffer} iv - The initialization vector used during encryption.
 * @param {Buffer} tag - The authentication tag generated during encryption.
 * @param {string} userId - The unique ID of the user.
 * @param {string} serverId - The unique ID of the server.
 * @returns {Promise<string>} - A promise that resolves to the decrypted plaintext message.
 */
export async function decryptMessageAsync(encryptedData: string, iv: Buffer, tag: Buffer, userId: string, serverId: string): Promise<string> {
    // Derive the decryption key asynchronously
    const key = await deriveKeyAsync(userId, serverId)

    // Create the AES-128-GCM decipher
    const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv)

    // Set the authentication tag for AES-GCM
    decipher.setAuthTag(tag)

    // Decrypt the message
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8')
    decrypted += decipher.final('utf8')

    return decrypted
}
